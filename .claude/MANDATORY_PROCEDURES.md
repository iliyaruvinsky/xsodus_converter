# MANDATORY PROCEDURES - CRITICAL

**READ THIS FILE AT THE START OF EVERY SESSION**

## üö® MANDATORY BUG-CHECKING PROCEDURE üö®

**EVERY TIME** a HANA error is encountered, you MUST follow this procedure **WITHOUT EXCEPTION**:

### Step 1: CHECK EXISTING BUGS FIRST
```
BEFORE doing ANYTHING else:
1. Read xml2sql/docs/bugs/BUG_TRACKER.md
2. Read xml2sql/docs/bugs/SOLVED_BUGS.md
3. Search for the error message/symptom
4. Check if this bug is already documented
```

### Step 2: CREATE BUG TICKET IF NEW
```
IF bug not found in either file:
1. Assign next BUG-XXX number
2. Add entry to BUG_TRACKER.md using the template
3. Fill in all required fields:
   - Error message
   - SQL fragment showing the issue
   - Root cause analysis
   - Affected XMLs
   - Proposed solution
   - Next steps
```

### Step 3: IMPLEMENT FIX
```
ONLY AFTER bug ticket is created:
1. Implement the fix
2. Test with the affected XML
3. Document code changes in the ticket
```

### Step 4: UPDATE DOCUMENTATION
```
AFTER successful HANA validation:
1. Move ticket from BUG_TRACKER.md to SOLVED_BUGS.md
2. Add solution details
3. Update bug statistics
```

### Step 5: BUG ID PRESERVATION (CRITICAL)
```
ONCE A BUG RECEIVES A BUG-XXX NUMBER, IT KEEPS THAT NUMBER FOREVER:
1. When bug is discovered: Document as BUG-XXX in BUG_TRACKER.md
2. In code comments: Use original ID (e.g., "# BUG-029: fix reason")
3. In git commits: Reference original ID (e.g., "BUGFIX: BUG-029 - description")
4. When resolved: Move to SOLVED_BUGS.md but KEEP original BUG-XXX ID
5. NEVER renumber bugs from BUG-XXX to SOLVED-XXX format

**Example Lifecycle**:
BUG-029 in tracker ‚Üí BUG-029 in code ‚Üí BUG-029 in commits ‚Üí BUG-029 in solved doc

**Why This Matters**:
Ensures complete traceability through code, commits, and documentation.
A developer searching for "BUG-029" in git history or code should find the same
bug documented in SOLVED_BUGS.md with the same ID.

**Historical Note**:
Bugs 001-028 used a dual numbering system (BUG-XXX ‚Üí SOLVED-XXX) which is now
DEPRECATED. Starting with BUG-029, all bugs keep their original ID permanently.
```

## ‚ö†Ô∏è CONSEQUENCES OF NOT FOLLOWING THIS PROCEDURE

- Wastes user's time and tokens
- Creates duplicate work
- Loses track of bug patterns
- Makes debugging harder
- BREAKS THE DEVELOPMENT PROCESS

## üìã QUICK REFERENCE

**Bug Tracker Location:** `xml2sql/docs/bugs/BUG_TRACKER.md`
**Solved Bugs Location:** `xml2sql/docs/bugs/SOLVED_BUGS.md`

**Process Flow:**
```
HANA Error ‚Üí Check BUG_TRACKER.md ‚Üí Check SOLVED_BUGS.md ‚Üí
Create ticket (if new) ‚Üí Implement fix ‚Üí Test ‚Üí Move to SOLVED_BUGS.md
```

## üîí THIS IS NON-NEGOTIABLE

This procedure was established because the assistant repeatedly failed to check existing documentation before implementing fixes, wasting significant time and resources.

**ALWAYS CHECK THE BUG TRACKER FIRST. NO EXCEPTIONS.**

---

## üö® MANDATORY SQL ANALYSIS PROCEDURE üö®

**EVERY TIME** you need to see generated SQL or analyze HANA errors, you MUST follow this procedure **WITHOUT EXCEPTION**:

### Step 1: READ LATEST_SQL_FROM_DB.txt YOURSELF
```
NEVER ask the user to copy/paste SQL.
ALWAYS read the file yourself:

File location: xml2sql/LATEST_SQL_FROM_DB.txt

BEFORE asking user for SQL:
1. Read xml2sql/LATEST_SQL_FROM_DB.txt
2. This file contains the latest SQL generated by the UI
3. This is what the user is testing in HANA Studio
4. NEVER say "can you paste lines X-Y" - READ THE FILE YOURSELF
```

### Step 2: ANALYZE THE SQL
```
After reading LATEST_SQL_FROM_DB.txt:
1. Identify the exact line with the error
2. Check if it matches any known bug patterns
3. Cross-reference with BUG_TRACKER.md and SOLVED_BUGS.md
4. Provide analysis based on what YOU READ, not what user pastes
```

### Step 3: UNDERSTAND SOURCE vs TARGET
```
CRITICAL architectural distinction:
1. SOURCE: Where HANA Calculation Views (CVs) are defined
   - Example: Content > Macabi_BI > Eligibility > CV_ELIG_TRANS_01
   - Package mapping xlsx/DB files map ONLY source locations

2. TARGET: Where generated SQL views are created
   - ALWAYS: "_SYS_BIC" catalog, "Views" folder
   - View name format: "_SYS_BIC"."Macabi_BI.Eligibility/CV_ELIG_TRANS_01"
   - Package path becomes PART OF THE VIEW NAME

DO NOT confuse source paths with target paths.
ALL generated SQL views go to _SYS_BIC > Views - ALWAYS.
```

## ‚ö†Ô∏è CONSEQUENCES OF NOT FOLLOWING THIS PROCEDURE

- Wastes user's time asking for SQL that's already in the repository
- Breaks the agreed workflow
- Shows you don't remember what was established
- Frustrates the user with repetitive requests
- DEMONSTRATES FAILURE TO LEARN FROM FEEDBACK

## üìã QUICK REFERENCE

**Latest SQL Location:** `xml2sql/LATEST_SQL_FROM_DB.txt`
**Action:** READ IT YOURSELF, NEVER ASK USER TO PASTE

**Process Flow:**
```
Need SQL ‚Üí Read LATEST_SQL_FROM_DB.txt ‚Üí Analyze ‚Üí Reference bug docs ‚Üí
Provide solution (NEVER ask user to paste SQL)
```

## üîí THIS IS NON-NEGOTIABLE

This procedure was established because the assistant repeatedly asked users to copy/paste SQL instead of reading the file that exists specifically for this purpose.

**READ LATEST_SQL_FROM_DB.txt YOURSELF. NEVER ASK USER TO PASTE SQL.**

---

## üö® MANDATORY SQL VALIDATION PROCEDURE üö®

**EVERY TIME** you generate SQL or analyze HANA errors, you MUST check for these common patterns **WITHOUT EXCEPTION**:

### CRITICAL SQL VALIDATION CHECKS

#### Check 1: String Column Filter Values Must Be Quoted
```
PATTERN TO FIND:
WHERE column_name = 01
WHERE column_name = 1
WHERE column_name = 0

PROBLEM:
Numeric literals (01, 1, 0) used for STRING columns cause type conversion errors.

CORRECT FORMAT:
WHERE column_name = '01'
WHERE column_name = '1'
WHERE column_name = '0'

HOW TO DETECT:
1. Search for pattern: WHERE.*=\s*\d+\s*(AND|OR|$)
2. Especially check numeric values with LEADING ZEROS (01, 001, 0001)
3. Look for error: "attribute value is not a number" or "invalid number"
4. Check SAP code columns: CODAPL, MANDT, BUKRS, etc. (often CHAR not INT)

HANA ERROR:
int("COLUMN_NAME") = 01, COLUMN_NAME = ''[string]
attribute value is not a number

BUG REFERENCE: BUG-026
```

#### Check 2: Empty WHERE Clauses After Parameter Cleanup
```
PATTERN TO FIND:
WHERE ()
WHERE (  )

PROBLEM:
After parameter cleanup, empty WHERE clauses remain causing syntax errors.

CORRECT FORMAT:
Omit WHERE clause entirely if no conditions remain.

BUG REFERENCE: BUG-022
```

#### Check 3: Package Paths in CREATE VIEW Names
```
PATTERN TO FIND:
CREATE VIEW "_SYS_BIC"."Package.Path/ViewName"

PROBLEM:
Package paths should NOT be in CREATE VIEW name (only in CV references).

CORRECT FORMAT:
CREATE VIEW "_SYS_BIC"."ViewName"

BUG REFERENCE: BUG-023 (NOTE: Analysis was wrong, but keep checking)
```

#### Check 4: Empty String IN Numeric Type Patterns
```
PATTERN TO FIND:
WHERE ('' IN (0) OR column IN (...))
WHERE '' IN (0)

PROBLEM:
Parameter substitution creates type mismatch patterns.

CORRECT FORMAT:
WHERE (column IN (...))

BUG REFERENCE: BUG-021
```

## ‚ö†Ô∏è VALIDATION WORKFLOW

**After generating ANY SQL, ALWAYS:**

```
1. Read LATEST_SQL_FROM_DB.txt
2. Search for unquoted numeric values in WHERE clauses:
   - grep -E "WHERE.*=\s*\d+" LATEST_SQL_FROM_DB.txt
3. Check for leading zeros specifically:
   - grep -E "=\s*0\d+" LATEST_SQL_FROM_DB.txt (finds 01, 001, etc.)
4. Check for empty WHERE:
   - grep "WHERE ()" LATEST_SQL_FROM_DB.txt
5. Report any findings immediately
```

## üîí WHY THIS MATTERS

**Real incident:** CURRENT_MAT_SORT.xml failed with "attribute value is not a number" because CODAPL (string column) had filter value `= 01` instead of `= '01'`. This is BUG-026.

**Rule:** When in doubt, QUOTE IT. SAP columns often use string types for codes that look numeric (01, 02, X, etc.).

---

## üö® MANDATORY POST-GENERATION VALIDATION CHECKS üö®

**EVERY TIME** SQL is generated, you MUST perform these validation checks **WITHOUT EXCEPTION**:

### Check 1: Parameter Cleanup Validation (BUG-026)
```
AFTER generating SQL with parameters, verify cleanup was successful:

1. Check for orphaned IN keywords:
   grep -E "IN\s+=" LATEST_SQL_FROM_DB.txt

2. Check for missing left operands:
   grep -E "\(\s*=" LATEST_SQL_FROM_DB.txt

3. Check for empty string comparisons:
   grep -E "[\'"]+\s*=\s*[\'"']+" LATEST_SQL_FROM_DB.txt

4. Check for unbalanced parentheses in WHERE:
   - Count opening: grep -o "WHERE.*(" LATEST_SQL_FROM_DB.txt
   - Count closing: grep -o "WHERE.*)" LATEST_SQL_FROM_DB.txt
   - Must match!

5. Check for empty WHERE clauses:
   grep "WHERE\s*(\s*)" LATEST_SQL_FROM_DB.txt

EXPECTED RESULT: No matches for any of these patterns

BUG REFERENCE: BUG-026
```

### Check 2: CTE Ordering Validation (BUG-028)
```
AFTER generating SQL with CTEs, verify dependency order is correct:

1. Extract all CTE definitions and their dependencies:
   - List all "CTE_NAME AS (" lines
   - For each CTE, find which other CTEs it references in FROM/JOIN

2. Verify topological order:
   - For each CTE X that references CTE Y
   - Y must appear BEFORE X in the WITH clause

3. Quick check - grep for undefined references:
   - No HANA error [259]: invalid table name

EXPECTED RESULT: All CTEs defined before they are referenced

BUG REFERENCE: BUG-028
```

### Check 3: Column Qualification in JOINs (BUG-027)
```
AFTER generating SQL with JOIN nodes:

1. Check for unqualified column names in calculated columns:
   - Find all "AS CC_" calculated columns in JOIN CTEs
   - Verify each raw column reference is qualified with table alias

2. Look for HANA error [268]: column ambiguously defined

3. Verify pattern:
   SELECT
      table_alias."COLUMN" AS CC_COLUMN  ‚Üê CORRECT (qualified)
   NOT:
      "COLUMN" AS CC_COLUMN              ‚Üê WRONG (unqualified)

EXPECTED RESULT: All calculated columns in JOIN contexts have qualified references

BUG REFERENCE: BUG-027
```

### Check 4: Empty WHERE Clause Patterns (BUG-021, BUG-022)
```
AFTER parameter cleanup, verify no malformed WHERE patterns:

1. Check for '' IN (0) patterns:
   grep "IN\s*(0)" LATEST_SQL_FROM_DB.txt

2. Check for completely empty WHERE:
   grep "WHERE\s*()" LATEST_SQL_FROM_DB.txt

3. Check for WHERE with only whitespace:
   grep "WHERE\s*(\s+)" LATEST_SQL_FROM_DB.txt

EXPECTED RESULT: No empty or malformed WHERE clauses

BUG REFERENCE: BUG-021, BUG-022
```

## ‚ö†Ô∏è VALIDATION FAILURE RESPONSE

**IF ANY VALIDATION CHECK FAILS:**

1. **STOP IMMEDIATELY** - Do not show SQL to user
2. **READ** the exact line with the error from LATEST_SQL_FROM_DB.txt
3. **CHECK** BUG_TRACKER.md and SOLVED_BUGS.md for similar patterns
4. **DOCUMENT** as new bug or reference existing bug number
5. **FIX** the issue in the appropriate function
6. **RE-GENERATE** SQL and re-run ALL validation checks
7. **ONLY THEN** show result to user

## üîí WHY VALIDATION MATTERS

**Real incidents:**
- BUG-026: CV_UPRT_PTLG had `( '''' = '')` (escaped empty string) - caught by Check 1
- BUG-028: CV_ELIG_TRANS_01 had join_1 before prj_visits - caught by Check 2
- BUG-027: CV_ELIG_TRANS_01 had unqualified "CALDAY" in JOIN - caught by Check 3

**Result:** These checks prevent shipping broken SQL to user for testing.

---

## üö® MANDATORY CODE CHANGE PROCEDURE üö®

**EVERY TIME** you modify core SQL generation code (renderer.py, function_translator.py, converter.py):

### Step 1: MINIMAL CHANGE PLANNING
```
BEFORE touching any code:
1. Identify the EXACT lines that need to change for this specific bug
2. List ONLY those lines - no "while I'm here" additions
3. Document what you plan to change and WHY
4. Ask yourself: "Is this change DIRECTLY related to the bug being fixed?"
5. If NO, don't make that change
```

### Step 2: SURGICAL IMPLEMENTATION
```
When implementing the fix:
1. Change ONLY the identified lines
2. Add inline comments explaining WHY each change is made
3. DO NOT touch any other functions or code blocks
4. DO NOT make "improvements" or "refactoring"
5. Keep track of every file and line number modified
```

### Step 3: IMMEDIATE VERIFICATION
```
After EACH change:
1. Read the file to verify the change
2. Test the specific bug is fixed
3. DO NOT proceed to next change until this one is verified
```

### Step 4: REGRESSION TESTING MANDATE
```
BEFORE showing results to user:
1. Read GOLDEN_COMMIT.yaml to get list of validated XMLs
2. Test EVERY validated XML still generates correct SQL
3. Compare output with golden SQL files if available
4. If ANY previously working XML breaks:
   - STOP IMMEDIATELY
   - REVERT ALL CHANGES: git restore <files>
   - Report the regression to user
   - DO NOT show "fix" that breaks working code
```

### Step 5: CHANGE ENUMERATION
```
Before reporting completion:
1. List EVERY file modified with exact line numbers
2. Explain WHAT changed in each location and WHY
3. Confirm you can enumerate ALL changes made
4. Example: "Modified 3 files:
   - renderer.py lines 645-654: Added column qualification
   - renderer.py lines 942-970: Added CV reference handling
   - converter.py lines 318-326: Removed package path from CREATE VIEW"
```

## ‚ö†Ô∏è CONSEQUENCES OF NOT FOLLOWING THIS PROCEDURE

- Makes extensive undocumented changes ‚Üí breaks working code
- Doesn't test against validated XMLs ‚Üí ships broken fixes
- Doesn't document changes ‚Üí impossible to debug
- Touches code that doesn't need touching ‚Üí introduces new bugs
- BREAKS ALL WORKING FUNCTIONALITY

## üìã REGRESSION TESTING QUICK REFERENCE

**Golden Commit File:** `xml2sql/GOLDEN_COMMIT.yaml`
**Validated XMLs Count:** Check `validated_xmls.count` in GOLDEN_COMMIT.yaml
**Test Method:** Regenerate each XML and compare SQL output

**Regression Test Command:**
```bash
cd xml2sql
python regression_test.py --compare-with-golden
```

## üîí CORE SQL GENERATION FILES - EXTREME CAUTION

These files control ALL SQL generation - one mistake breaks EVERYTHING:
- `src/xml_to_sql/sql/renderer.py` - Main SQL renderer
- `src/xml_to_sql/sql/function_translator.py` - Function translation
- `src/xml_to_sql/web/services/converter.py` - View name generation

**When modifying these files:**
- Treat like brain surgery - ONE wrong move ruins everything
- Test after EVERY SINGLE change
- Never make multiple changes before testing
- If you changed 198 lines, you probably broke everything

## üìä FAILURE INCIDENT LOG

### Incident 1: Session 8 (2025-11-20)
**What Happened:** Made 198 undocumented changes to renderer.py while fixing BUG-023/024/025
**Impact:** Broke ALL 8 previously validated XMLs
**Root Cause:**
- Did not follow minimal change principle
- Did not test against validated XMLs before showing results
- Did not document each change made
- Touched code that didn't need to be touched
**Resolution:** Emergency git revert, lost all fix work
**Lesson:** THESE PROCEDURES EXIST FOR A REASON

---

## üéØ SUCCESS CRITERIA

Before claiming "fix complete":
- ‚úÖ Bug-specific changes only (no extras)
- ‚úÖ All changes documented with line numbers
- ‚úÖ All validated XMLs still work (regression test passed)
- ‚úÖ Can enumerate every single change made
- ‚úÖ User can review exactly what changed and why
